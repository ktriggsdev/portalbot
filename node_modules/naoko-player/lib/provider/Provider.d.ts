/// <reference types="node" />
/// <reference types="node" />
import { Static } from "@sinclair/typebox";
import { Readable } from "node:stream";
import fs = require("node:fs");
import { LoadResultType } from "../utils/consts";
declare const TypeboxTrack: import("@sinclair/typebox").TObject<{
    name: import("@sinclair/typebox").TString;
    provider: import("@sinclair/typebox").TString;
    encodedId: import("@sinclair/typebox").TString;
    description: import("@sinclair/typebox").TString;
    authorName: import("@sinclair/typebox").TString;
    authorURL: import("@sinclair/typebox").TString;
    sourceURL: import("@sinclair/typebox").TString;
}>;
declare const TypeboxPlaylist: import("@sinclair/typebox").TObject<{
    name: import("@sinclair/typebox").TString;
    provider: import("@sinclair/typebox").TString;
    description: import("@sinclair/typebox").TString;
    authorName: import("@sinclair/typebox").TString;
    authorURL: import("@sinclair/typebox").TString;
    sourceURL: import("@sinclair/typebox").TString;
    tracks: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        name: import("@sinclair/typebox").TString;
        provider: import("@sinclair/typebox").TString;
        encodedId: import("@sinclair/typebox").TString;
        description: import("@sinclair/typebox").TString;
        authorName: import("@sinclair/typebox").TString;
        authorURL: import("@sinclair/typebox").TString;
        sourceURL: import("@sinclair/typebox").TString;
    }>>;
}>;
type ITrack = Static<typeof TypeboxTrack>;
type IPlaylist = Static<typeof TypeboxPlaylist>;
type SearchResultType<Track extends ITrack = ITrack, Playlist extends IPlaylist = IPlaylist> = (Track | Playlist)[];
declare abstract class Provider {
    static cache: Map<string, {
        name: string;
        description: string;
        provider: string;
        encodedId: string;
        authorName: string;
        authorURL: string;
        sourceURL: string;
    }>;
    static cache_path: string;
    readonly provider: string;
    constructor(provider: string);
    abstract get cacheIsAllowed(): boolean;
    abstract loadTracks(query: string, loadType: LoadResultType.Track): Promise<ITrack[]>;
    abstract loadTracks(query: string, loadType: LoadResultType.Playlist): Promise<IPlaylist[]>;
    abstract loadTracks(query: string, loadType: LoadResultType): Promise<SearchResultType>;
    abstract getTrackStream(track: ITrack): Promise<Readable>;
    static assignAssetId(provider: string, track: ITrack): string;
    static checkIfCached(id: string): boolean;
    static getCacheStream(id: string): fs.ReadStream;
    static createCacheStream(id: string): fs.WriteStream;
}
export { Provider, ITrack, IPlaylist, SearchResultType };
