"use strict";
const path = require("node:path");
const Provider_1 = require("../Provider");
const fs = require("node:fs");
const consts_1 = require("../../utils/consts");
class LocalProvider extends Provider_1.Provider {
    constructor() {
        super("local");
    }
    get cacheIsAllowed() {
        return false;
    }
    /** Loads and returns a specified audio file */
    async loadTracks(query, loadType) {
        if (!fs.existsSync(query))
            throw new ProviderError('Local', `specified path does not exists! \n\tQuery: '${query}'`);
        const stat = await fs.promises.stat(query);
        if (stat.isFile() && loadType !== consts_1.LoadResultType.Playlist) {
            return [await this.loadFile(query)];
        }
        switch (loadType) {
            case consts_1.LoadResultType.Search: {
                const readdir = await fs.promises.readdir(query);
                return await Promise.all(readdir.map(async (x) => await this.loadFile(path.join(query, x)) || await this.loadPlaylist(x)));
            }
            case consts_1.LoadResultType.Track: {
                const readdir = await fs.promises.readdir(query);
                return (await Promise.all(readdir.map(async (x) => await (this.loadFile(path.join(query, x)).catch(() => null)))))
                    .filter(x => x);
            }
            case consts_1.LoadResultType.Playlist: {
                const readdir = await fs.promises.readdir(query);
                return (await Promise.all(readdir.map(async (x) => await (this.loadPlaylist(path.join(query, x)).catch(() => null)))))
                    .filter(x => x);
            }
        }
        return [];
    }
    /** Loads a directory and returns tracks with audio codecs */
    async loadPlaylist(query) {
        if (!fs.existsSync(query))
            throw new ProviderError('Local', `specified path does not exists! \n\tQuery: '${query}'`);
        const stat = await fs.promises.stat(query);
        if (stat.isDirectory()) {
            const list = await fs.promises.readdir(query);
            const tracks = await Promise.all(list.map(async (x) => await this.loadFile(path.join(query, x))));
            const playlist = {
                name: path.basename(query),
                provider: this.provider,
                description: '',
                authorName: 'filesystem',
                authorURL: path.join(query, '..'),
                sourceURL: query,
                tracks: tracks.filter(x => x)
            };
            return playlist;
        }
        throw new ProviderError('Local', 'path was not a directory!\n\tQuery:' + query);
    }
    async loadFile(queryPath) {
        const stat = await fs.promises.stat(queryPath);
        if (!stat.isFile())
            return;
        if (!this.checkIsValid(path.extname(queryPath)))
            return;
        return this.buildTrack(queryPath);
    }
    async getTrackStream(track) {
        const file = fs.createReadStream(track.sourceURL);
        return file;
    }
    checkIsValid(extname) {
        switch (extname) {
            case '.mp3': return true;
            case '.opus': return true;
            case '.vorbis': return true;
            case '.ogg': return true;
            case '.aac': return true;
            case '.m4a': return true;
        }
        return false;
    }
    buildTrack(source) {
        const track = {
            name: path.basename(source),
            description: '',
            authorName: 'filesystem',
            authorURL: path.join(source, '..'),
            provider: this.provider,
            encodedId: '',
            sourceURL: source
        };
        Provider_1.Provider.assignAssetId(this.provider, track);
        return track;
    }
}
module.exports = LocalProvider;
