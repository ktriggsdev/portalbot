"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const node_path_1 = __importDefault(require("node:path"));
const node_stream_1 = __importDefault(require("node:stream"));
const fs_1 = __importDefault(require("fs"));
const BPS = 192000;
const DEFAULT_CHUNK_LENGTH = 3800;
class AudioAssetStream extends node_stream_1.default.PassThrough {
    // static cache_directory = path.join(os.tmpdir(), 'naoko_music_sounds');
    static createAssetId(track) {
        return Buffer.from(`Asset:${track.provider}_${track.sourceURL}`).toString('base64url');
    }
    static createAssetStream(track) {
        const encodedId = track.encodedId || this.createAssetId(track);
        const stream = new AudioAssetStream(encodedId, track);
        return stream;
    }
    constructor(id, metadata) {
        super();
        this.id = id;
        this.metadata = metadata;
        this.bytesSent = 0;
        this.cachedSeconds = 0;
        this.writers = new Set();
        this._cachedaudio = false;
        if (fs_1.default.existsSync(node_path_1.default.join(AudioAssetStream.cache_directory, id))) {
            this._cachedaudio = true;
        }
    }
    startAudioCache() {
        if (!this._cachedaudio) {
            const fullWriter = fs_1.default.createWriteStream(node_path_1.default.join(AudioAssetStream.cache_directory, this.id));
            this.writers.add(fullWriter);
            this.pipe(fullWriter);
            fullWriter.once('close', () => {
                this.writers.delete(fullWriter);
                this._cachedaudio = true;
                this.unpipe(fullWriter);
            });
        }
        return true;
    }
    get isAudioCached() {
        return this._cachedaudio;
    }
    getAssetStream() {
        if (!this._cachedaudio)
            throw new Error('requested to use cache, but file doesnt exists!');
        const stream = fs_1.default.createReadStream(node_path_1.default.join(AudioAssetStream.cache_directory, this.id));
        this.audioStream = stream;
        this.audioStream.pipe(this);
        return stream;
    }
    async downloadAssetStream(manager) {
        const provider = manager.providers.get(this.metadata.provider);
        if (!provider)
            throw new Error('no provider for track!');
        const stream = await provider.getTrackStream(this.metadata);
        this.audioStream = stream;
        this.audioStream.pipe(this);
        return stream;
    }
    _transform(chunk, encoding, callback) {
        this.bytesSent += chunk.length;
        this.cachedSeconds += chunk.length / BPS;
        callback(null, chunk);
    }
}
AudioAssetStream.cache_directory = node_path_1.default.join(process.cwd(), 'sounds', 'cache');
module.exports = AudioAssetStream;
