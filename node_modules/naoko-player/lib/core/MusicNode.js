"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const voice_1 = require("@discordjs/voice");
const stream_1 = __importDefault(require("stream"));
const AudioSkipper_1 = __importDefault(require("./AudioSkipper"));
const AudioAssetStream_1 = __importDefault(require("./AudioAssetStream"));
const node_path_1 = __importDefault(require("node:path"));
const BPS = 192000;
class MusicNode {
    constructor(guildId, manager) {
        this.guildId = guildId;
        this.manager = manager;
        this._player = (0, voice_1.createAudioPlayer)();
        manager['nodes'].set(guildId, this);
    }
    get connection() {
        return (0, voice_1.getVoiceConnection)(this.guildId);
    }
    async playTrack(track) {
        const provider = this.manager.providers.get(track.provider);
        if (!provider)
            throw new Error('no provider');
        const audioAsset = AudioAssetStream_1.default.createAssetStream(track);
        const audioResource = this._createAudioResource();
        if (this._audio && this._resource) {
            this._audio.unpipe(this._resource.metadata);
        }
        this._audio = audioAsset;
        this._resource = audioResource;
        audioAsset.pipe(this._resource.metadata);
        if (!audioAsset.isAudioCached) {
            const writers = Array.from(audioAsset.writers.keys());
            const writer = writers.find(x => node_path_1.default.basename(x.path.toString()) === track.encodedId);
            if (writer) {
                await new Promise((res) => writer.once('close', res));
                audioAsset.getAssetStream();
            }
            else {
                await audioAsset.downloadAssetStream(this.manager);
            }
        }
        else {
            audioAsset.getAssetStream();
        }
        if (this.manager.options?.cacheEnabled && provider.cacheIsAllowed && !audioAsset.isAudioCached) {
            audioAsset.startAudioCache();
        }
        this._player.play(audioResource);
    }
    async skipForward(seconds) {
        if (!(this._audio && this._resource))
            return false;
        const skipper = new AudioSkipper_1.default(this._audio, seconds);
        this._audio.unpipe(this._resource.metadata);
        this._audio.pipe(skipper);
        await new Promise((res) => skipper.once('close', res));
    }
    stop() {
        if (!(this._audio && this._resource))
            return false;
        this._audio.unpipe(this._resource.metadata);
        this._player.stop();
        return true;
    }
    _createAudioResource() {
        let stream = new stream_1.default.PassThrough();
        // Do if ffmpeg
        const audio = (0, voice_1.createAudioResource)(stream, {
            metadata: stream,
            inputType: voice_1.StreamType.Arbitrary,
            inlineVolume: true
        });
        return audio;
    }
}
module.exports = MusicNode;
